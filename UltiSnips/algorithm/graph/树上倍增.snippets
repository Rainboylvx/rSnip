# 树上倍增
snippet lca_jump "树上倍增" b
//============= 树上倍增 BEG
/* 初始化   LCA_JUMP::lca_init(点的数量)
 * 建立st表 LCA_JUMP::st_dfs(root,depth,father)
 * 查询lca  LCA_JUMP::find_lca(u,v)
 * 查询距离 LCA_JUMP::get_dis(u,v)
 * */
namespace LCA_JUMP {
    using namespace xlx1;
    const int DEPTH = 100;
    int d[maxn],f[maxn],p[maxn][30],MAX_DEPTH;
    void lca_init(int size=maxn){ MAX_DEPTH = int(log(size)/log(2));}

    void st_dfs(int u,int dep,int fa=0){
        p[u][0] = fa,d[u] = dep;
        for(int i = 1; i <= MAX_DEPTH ;i++) p[u][i] = p[ p[u][i-1]][i-1];
        for(int i= head[u]; ~i ;i = e[i].next) if( e[i].v != fa) st_dfs(e[i].v,dep+1,u);
    }

    int find_lca(int u,int v){
        if( d[u] > d[v]) std::swap(u,v); // 保证: v 是深度深的点
        for(int i = MAX_DEPTH;i>=0;i--) if( d[v] - (1<<i) >= d[u]) v = p[v][i];
        if( u == v) return u;
        for(int i = MAX_DEPTH;i>=0;i--) if( p[u][i] != p[v][i]) u = p[u][i], v= p[v][i];
        return p[v][0];
    }
    long long get_dis(int u,int v){
        long long sum = 0; if( d[u] > d[v]) std::swap(u,v); // 保证: v 是深度深的点
        for(int i = MAX_DEPTH;i>=0;i--) if( d[v] - (1<<i) >= d[u]) v = p[v][i],sum+=(1<<i);
        if( u == v) return sum;
        for(int i = MAX_DEPTH;i>=0;i--) if( p[u][i] != p[v][i]) u = p[u][i], v= p[v][i],sum+=(1<<i)<<1;
        return sum+2;
    }
}
//============= 树上倍增 END
endsnippet
