# === 向量星 ===
# 作用: 存储图的数据结构
# author:Rainboy

snippet xlx "向量星" b
/* ========= 向量星 ${1:1} =========*/
namespace xlx$1 {
    int head[maxn],edge_cnt = 0;
    struct _e{ int u,v,w,next; }e[maxe];
    void inline xlx_init(){ edge_cnt = 0; memset(head,-1,sizeof(head)); } 
    void addEdge(int u,int v,int w=0){ e[++edge_cnt] = { .u = u,.v=v,.w=w,.next =head[u]}; head[u] = edge_cnt; }
}
/* ========= 向量星 $1 END =========*/
endsnippet

## edge_u for
snippet ee "Each edge from head u" b
for(${1:i}= xlx${2:1}::head[${3:u}]; ~$1 ;$1 = xlx$2::e[$1].next){
	int &v = xlx$2::e[$1].v; int &w = xlx$2::e[$1].w;
	$0
}
endsnippet



# 类型-向量星
snippet xlx_class "向量星-类" b
struct xlx{
    typedef struct  { int u,v,w,next;} node;
    int edge_cnt=0;
    vector<int> head;
    vector<node> e;

    /* 构造函数,点的数量 */
    xlx(int n){
        head = vector<int> (n,-1);
    }

    void add_edge(int u,int v,int w){
        e.push_back({.u = u ,.v = v ,.w = w ,.next = head[u]});
        head[u] = edge_cnt;
        edge_cnt++;
    }

    void add_edge(int u,int v){
        e.push_back({.u = u ,.v = v ,.w = 0 ,.next = head[u]});
        head[u] = edge_cnt;
        edge_cnt++;
    }

	/* 遍历u周围的点 */
    template<class UnaryPredicate>
    void forEach(int u,UnaryPredicate p){
        int i;
        for(i = head[u];i!=-1;i = e[i].next){
            p(e[i].u,e[i].v,e[i].w);
        }
    }
};
${0}
endsnippet
