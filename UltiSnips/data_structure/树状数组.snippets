snippet BIT "树状数组" b
/* ============ BIT BEG ============ */
namespace BIT {
    /* 单点更新 区间查询 */
    ll c[maxn],size;
    #define lowbit(x) (x &(-x))
    inline void bit_init(ll s=maxn){ memset(c,0,sizeof(c)); size=s;}
    void update_s(ll pos,ll num)    { for(;pos <=size ; pos+=lowbit(pos)) c[pos] +=num; }
    ll query(ll pos)  { ll sum =0; for( ;pos >0; pos-=lowbit(pos)) sum+=c[pos]; return sum;}
}
/* ============ BIT END ============ */
endsnippet


# 求区间最值-最大值
snippet bit_max "Description" b
/* ============ BIT range Max BEGIN ============ */
int a[maxn],c[maxn];
inline int lowbit(int x){ return x &(-x); } 
/* pos 位置,v 数值 */
void update(int pos,int v){
    int i,lb;
    a[pos] = v;
    lb = lowbit(pos);
    for(i=1;i<lb;i <<=1){ //利用孩子更新自己
        if( v <= c[pos-i]) //v 并不是最大的点
            return;
    }
    c[pos] = v;
    pos+=lowbit(pos);//父亲的位置

    /* 更新父亲 */
    while(pos <= n){
        if( c[pos] < v){ //更新的父亲
            c[pos] = v;
            pos +=lowbit(pos);
        }           //没有更新父亲
        else break;
    }
}

void push(int pos){
    int i,lb = lowbit(pos);
    c[pos] = a[pos];
    for(i=1;i<lb;i <<=1){
        c[pos] = max(c[pos],c[pos-i]);
    }

}
int query(int x,int y){

    int res = -1;
    while(x <= y){
        int nx = y - lowbit(y)+1;
        if(nx >= x ){
            res = res < c[y] ? c[y] :res;
            y = nx-1; // 下一个求解区间
        }
        else { // nx < x
            res = res < a[y] ? a[y] :res;
            y--;
        }
    }
    return res;
}
/* ============ BIT range Max END ============ */
${0}
endsnippet

# 求区间最值-最小值
snippet bit_min "Description" b

endsnippet
