snippet slpf "树链剖分" b


/* =====  树链剖分 ====*/
int son[maxn], top[maxn], dep[maxn], fa[maxn], size[maxn];

inline void slpf_init() { //初始化
    memset(son,-1,sizeof(son));
}

// dfs1 求 son[maxn], dep[maxn], fa[maxn], size[maxn];
void dfs1(int u,int pre,int d){
    dep[u] = d;
    fa[u] = pre;
    size[u] = 1;
    int i;
    for(i=head[u];i!=-1;i=e[i].next){
        int v = e[i].v;
        if( v == pre) continue;
        dfs1(v,u,d+1);
        size[u] += size[v];
        if(son[u] == -1 || size[v] > size[ son[u] ])
            son[u] = v;
    }
}

// dfs2 连重边为重链,求 top[maxn]
void dfs2(int u,int sf){
    top[u] = sf;
    if(son[u] != -1)
        dfs2(son[u],sf);
    else
        return ;
    int i;

    for(i=head[u];i!=-1;i=e[i].next){
        int v = e[i].v;
        if( v!= son[u] && v != fa[u])
            dfs2(v,v);
    }
}



//跨链,找到lca(x,y)
int lca_find(int x,int y){
    //找到两个点的重链的顶端点
    int f1 = top[x],f2 = top[y];
    int tmp = 0;
    while(f1 != f2){

        //从深度较深的点 向上爬
        if( dep[f1] < dep[f2]){
            swap(f1,f2);
            swap(x,y);
        }
        //交换后 y所在重链的 dep[ top[y] ] < dep[ top[x] ]
        //x top[x] 较深

        //跨链
        x =  fa[f1];
        f1 = top[x];
    }

    //返回较浅的那个点
    if( dep[x] > dep[y])
        swap(x,y);
    return x;
}

/* =====  树链剖分 end ====*/

endsnippet
